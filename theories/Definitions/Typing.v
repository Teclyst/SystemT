Require Import Definitions.Type.
Require Import Definitions.Term.
Require Import Definitions.Context.
Require Import Theorems.Type.
Require Import Theorems.Unification.

Require Import List.

Open Scope system_t_type_scope.
Open Scope system_t_term_scope.

Inductive derivation : Context.t -> termT -> typeT -> Prop :=
  | bvarT_ax :
    forall G : Context.t, forall n : nat, forall t : typeT,
    Context.bMapsTo n t G ->
    derivation G (bvarT n) t
  | fvarT_ax :
    forall G : Context.t, forall s : TMap.t typeT,
    forall x : FIdent.t, forall t : typeT,
    Context.fMapsTo x t G ->
    derivation G (fvarT x) (par_tsubst s t)
  | absT_in :
    forall G : Context.t, forall e : termT, forall t u : typeT,
    derivation (Context.bpush t G) e u ->
    derivation G (absT e) (t ->T u)
  | appT_el :
    forall G : Context.t, forall e f : termT, forall t u : typeT,
    derivation G e (t ->T u) ->
    derivation G f t ->
    derivation G (appT e f) u
  | pairT_in :
    forall G : Context.t, forall e f : termT, forall t u : typeT,
    derivation G e t ->
    derivation G f u ->
    derivation G (pairT e f) (t *T u)
  | plT_el :
    forall G : Context.t, forall e : termT, forall t u : typeT,
    derivation G e (t *T u) ->
    derivation G (plT e) t
  | prT_el :
    forall G : Context.t, forall e : termT, forall t u : typeT,
    derivation G e (t *T u) ->
    derivation G (prT e) u
  | trueT_ax :
    forall G : Context.t, derivation G trueT boolT
  | falseT_ax :
    forall G : Context.t, derivation G falseT boolT
  | iteT_el :
    forall G : Context.t, forall e f g : termT, forall t : typeT,
    derivation G e boolT ->
    derivation G f t ->
    derivation G g t ->
    derivation G (iteT e f g) t
  | oT_ax :
    forall G : Context.t, derivation G oT natT
  | sT_el :
    forall G : Context.t, forall e : termT,
    derivation G e natT ->
    derivation G (sT e) natT
  | recT_el :
    forall G : Context.t, forall e f g : termT, forall t : typeT,
    derivation G e t ->
    derivation G f (t ->T natT ->T t) ->
    derivation G g natT ->
    derivation G (recT e f g) t.

Notation "G |- e :T t" := (derivation G e t) (at level 90) :
    system_t_type_scope.

Notation "|- e :T t" := (derivation Context.empty e t) (at level 90) :
    system_t_type_scope.

Variant type_error :=
  | type_error_unification_error : unification_error -> type_error
  | type_error_unbound_bvarT : type_error. (* This case shouldn't occur
    for terms generated by the interpreter, so we don't try to retrieve
    the erroring value. *)

Definition instantiate_typeT (used_tvars : list TIdent.t) (t : typeT) :
    TMap.t typeT * list TIdent.t :=
    let variable_list := TSet.elements (variable_set t) in
    let s : TMap.t TIdent.t := 
      TIdentFacts.new_map used_tvars variable_list in
    (TMap.map tvarT s,
      map
        (fun x =>
          match TMap.find x s with
          | Some y => y
          | None => TIdent.new nil
          end)
        variable_list).

Fixpoint build_unification_problem
  (used_tvars : list TIdent.t) (G : Context.t) (e : termT) : 
    option (unification_problem * list TIdent.t) :=
  let term_type := TIdent.new used_tvars in
  match e with
  | bvarT n =>
    option_map
      (fun t => ((tvarT term_type, t) :: nil, term_type :: used_tvars))
      (List.nth_error (Context.bmap G) n)
  | fvarT x =>
    option_map
      (fun t =>
        let (s, new_used_tvars) :=
          instantiate_typeT (term_type :: used_tvars) t in
        ((tvarT term_type, t >> s) :: nil,
         term_type :: new_used_tvars ++ used_tvars))
      (FMap.find x (Context.fmap G))
  | absT e =>
    let var_type := TIdent.new (term_type :: used_tvars) in
    let body_type := TIdent.new (var_type :: term_type :: used_tvars) in
    match
      build_unification_problem
        (var_type :: term_type :: used_tvars)
        (bpush (tvarT var_type) G)
        e with
    | Some (p, used_tvars) =>
      Some ((tvarT term_type, tvarT var_type ->T tvarT body_type) :: p,
        used_tvars)
    | _ => None
    end
  | appT e f =>
    let fun_type := TIdent.new (term_type :: used_tvars) in
    match build_unification_problem (term_type :: used_tvars) G e with
    | Some (p_fun, used_tvars) =>
      let arg_type := TIdent.new used_tvars in
      match (build_unification_problem used_tvars G f) with
      | Some (p_arg, used_tvars) =>
        Some
          ((tvarT fun_type, tvarT arg_type ->T tvarT term_type) ::
            p_arg ++ p_fun,
            used_tvars)
      | _ => None
      end
    | _ => None
    end
  | pairT e f =>
    let left_type := TIdent.new (term_type :: used_tvars) in
    match build_unification_problem (term_type :: used_tvars) G e with
    | Some (p_left, used_tvars) =>
      let right_type := TIdent.new used_tvars in
      match (build_unification_problem used_tvars G f) with
      | Some (p_right, used_tvars) =>
        Some
          ((tvarT term_type, tvarT left_type *T tvarT right_type) ::
            p_right ++ p_left,
            used_tvars)
      | _ => None
      end
    | _ => None
    end
  | plT e =>
    let right_type := TIdent.new (term_type :: used_tvars) in
    let pair_type := TIdent.new (right_type :: term_type :: used_tvars) in
    match
      build_unification_problem
        (right_type :: term_type :: used_tvars) G e with
    | Some (p, used_tvars) =>
      Some ((tvarT pair_type, tvarT term_type *T tvarT right_type) :: p,
        used_tvars)
    | _ => None
    end
  | prT e =>
    let left_type := TIdent.new (term_type :: used_tvars) in
    let pair_type := TIdent.new (left_type :: term_type :: used_tvars) in
    match
      build_unification_problem
        (left_type :: term_type :: used_tvars) G e with
    | Some (p, used_tvars) =>
      Some ((tvarT pair_type, tvarT left_type *T tvarT term_type) :: p,
        used_tvars)
    | _ => None
    end
  | falseT | trueT =>
    Some ((tvarT term_type, boolT) :: nil, term_type :: used_tvars)
  | iteT e f g =>
    let if_type := TIdent.new (term_type :: used_tvars) in
    match build_unification_problem (term_type :: used_tvars) G e with
    | Some (p_if, used_tvars) =>
      let then_type := TIdent.new used_tvars in
      match (build_unification_problem used_tvars G f) with
      | Some (p_then, used_tvars) =>
        let else_type := TIdent.new used_tvars in
        match (build_unification_problem used_tvars G g) with
        | Some (p_else, used_tvars) =>
          Some
            ((tvarT term_type, tvarT then_type) ::
              (tvarT then_type, tvarT else_type) ::
              (tvarT if_type, boolT) ::
            p_else ++ p_then ++ p_if,
            used_tvars)
          | _ => None
        end
      | _ => None
      end
    | _ => None
    end
  | oT =>
    Some ((tvarT term_type, natT) :: nil, term_type :: used_tvars)
  | sT e =>
    let arg_type := TIdent.new (term_type :: used_tvars) in
    match build_unification_problem (term_type :: used_tvars) G e with
    | Some (p, used_tvars) =>
      Some ((tvarT term_type, natT) :: (tvarT arg_type, natT) :: p,
        used_tvars)
    | _ => None
    end
  | recT e f g =>
    let base_type := TIdent.new (term_type :: used_tvars) in
    match build_unification_problem (term_type :: used_tvars) G e with
    | Some (p_base, used_tvars) =>
      let rec_type := TIdent.new used_tvars in
      match (build_unification_problem used_tvars G f) with
      | Some (p_rec, used_tvars) =>
        let arg_type := TIdent.new used_tvars in
        match (build_unification_problem used_tvars G g) with
        | Some (p_arg, used_tvars) =>
          Some
            ((tvarT term_type, tvarT base_type) ::
              (tvarT arg_type, natT) ::
              (tvarT rec_type,
                tvarT base_type ->T natT ->T tvarT base_type) ::
            p_arg ++ p_rec ++ p_base,
            used_tvars)
          | _ => None
        end
      | _ => None
      end
    | _ => None
    end
  end.

Definition type_check (tenv : FMap.t typeT) (e : termT) :
    result typeT type_error :=
  match
    build_unification_problem
      nil {| Context.bmap := nil; Context.fmap := tenv |} e
  with
  | Some (p, _) =>
    match unify p with
    | ok s =>
      ok (tvarT (TIdent.new nil) >> s)
    | err error =>
      err (type_error_unification_error error)
    end
  | _ =>
    err type_error_unbound_bvarT
  end.
